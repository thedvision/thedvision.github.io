<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>[DEMO] video play</title>
    <style>
        body {
            margin: 0;
            font-family: sans-serif;
        }
        .is-hidden {
            display: none;
        }
        .input-block {
            margin: 2rem;
        }
        .input-block .link-label {
            display: inline-block;
            font-size: 0.85rem;
            padding: 0.5rem 0.8rem;
            background-color: #222;
            color: #FFF;
            border-radius: 1rem;
        }
        .input-block .guide {
            font-size: 0.8rem;
            color: #555;
            margin-left: 0.5rem;
        }
        .video-viewer-wrapper {
            margin: 2rem;
            background-color: #000;
            color: #FFF;
        }
        .viewer {
            padding: 1rem;
        }
        .viewer video {
            box-sizing: border-box;
            display: block;
            max-width: 100%;
            height: auto;
            margin: auto;
        }
        #playback-control {
            margin-bottom: 1rem;
            text-align: center;
        }
        #playback-control.playing #play-btn { display: none; }
        #playback-control.playing #pause-btn { display: initial; }
        #playback-control.paused #play-btn { display: initial; }
        #playback-control.paused #pause-btn { display: none; }

        .seeking-wrapper {
            position: relative;
        }
        .streams {
            margin: 0;
            padding: 0;
            overflow: hidden;
            list-style-type: none;
            pointer-events: none;
        }
        .streams li {
            float: left;
            width: 10%;
            pointer-events: inherit;
        }
        .streams li canvas {
            display: block;
            width: 100%;
            pointer-events: inherit;
        }
        .cur-time-marker {
            position: absolute;
            top: 0;
            bottom: 0;
        }
        .cur-time-marker .cur-time-bar {
            height: 100%;
            width: 1px;
            box-sizing: border-box;
            border-left: 1px solid red;
        }
        .seeking-handle {
            width: 9px;
            height: 9px;
            border-radius: 10px;
            position: absolute;
            top: calc(50% - 5px);
            left: -4px;
            background-color: red;
        }
        #playback-control {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #playpause-btn {
            display: inline-block;
            margin-right: 1rem;
        }
        #playpause-btn .icons {
            pointer-events: none;
            display: block;
        }
        #playpause-btn .pause-text {display: none;}
        #playpause-btn.playing .play-text {display: none;}
        #playpause-btn.playing .pause-text {display: block;}
    </style>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
<div class="input-block">
    <label for="src" class="link-label">동영상 파일 업로드</label>
    <span class="guide">.webm 파일만 가능합니다.</span>
    <input type="file" id="src" class="is-hidden">
</div>
<div class="video-viewer-wrapper is-hidden">
    <div class="viewer">
        <video id="view"></video>
    </div>
    <div class="controls">
        <div id="playback-control">
            <div id="playpause-btn">
                <i class="material-icons play-text icons">play_arrow</i>
                <i class="material-icons pause-text icons">pause</i>
            </div>
            <div class="time-block">
                <span id="cur-time-text">0:00</span>
                <span> / </span>
                <span id="duration-text">0:00</span>
            </div>
        </div>
        <div id="seeking-control"  class="seeking-wrapper">
            <ul id="stream-preview" class="streams"></ul>
            <div id="cur-time-marker" class="cur-time-marker">
                <div class="cur-time-bar"></div>
                <div id="seeking-handle" class="seeking-handle"></div>
            </div>
        </div>
    </div>
</div>
<canvas id="dst"></canvas>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script type="text/javascript">
    const src = document.querySelector('#src');
    const view = document.querySelector('#view');
    const dst = document.querySelector('#dst');
    const videoViewer = document.querySelector('.video-viewer-wrapper');
    const playPauseBtn = document.querySelector('#playpause-btn');
    const curTimeText = document.querySelector('#cur-time-text');
    const durationText = document.querySelector('#duration-text');
    const seekingCtrl = document.querySelector('#seeking-control');
    const streamPreview = document.querySelector('#stream-preview');
    const curTimeMarker = document.querySelector('#cur-time-marker');
    const seekingHandle = document.querySelector('#seeking-handle');
    const ctx = dst.getContext('2d');
    const stream = dst.captureStream(0);
    const recorder = new MediaRecorder(stream, {mimeType: 'video/webm; codecs=vp9'});
    const recordedChunks = [];
    const previewTimes = [];
    let seekingCtrlBBox;
    let previewScale;


    window.addEventListener('resize', e => {
        seekingCtrlBBox = seekingCtrl.getBoundingClientRect();
        previewScale.domain([0, seekingCtrlBBox.width - 1]);
        moveHandlePosition();
    });

    view.addEventListener('loadedmetadata', e => {
        dst.width = view.videoWidth;
        dst.height = view.videoHeight;

        videoViewer.classList.remove('is-hidden');
        seekingCtrlBBox = seekingCtrl.getBoundingClientRect();

        previewScale = d3.scaleLinear()
            .domain([0, seekingCtrlBBox.width - 1])
            .range([0, view.duration]);

        durationText.textContent = convertTimeText(view.duration);

        const previewCount = 10;
        const interval = view.duration / previewCount;
        for (let i = 0; i < previewCount; i++) {
            previewTimes.push(interval * i)
        }
        capturePreviews();
    });

    recorder.ondataavailable = e => {
        if (e.data.size === 0) return;
        recordedChunks.push(e.data);
    };

    recorder.onstop = e => {
        const blob = new Blob(recordedChunks, {type: 'video/webm'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        document.body.appendChild(a);
        a.style = 'display: none';
        a.href = url;
        a.download = 'output.webm';
        a.click();
        window.URL.revokeObjectURL(url);
    };

    src.addEventListener('change', e => {
        const uploaded = (e.target || e.srcElement).files[0];
        if (uploaded.type !== 'video/webm') return;

        const reader = new FileReader();
        reader.onload = file => {
            const fileContent = file.target.result;
            view.setAttribute('src', fileContent);
            // view.play();
            // recorder.start();
            // copy();
        };
        reader.readAsDataURL(uploaded);
    });

    function copy() {
        if (view.ended) {
            recorder.stop();
            return;
        }
        ctx.drawImage(view, 0, 0);

        ctx.fillStyle = '#FFF';
        ctx.font = '100px Arial';
        ctx.fillText('Hello', 10, 100);
        stream.getVideoTracks()[0].requestFrame();

        window.requestAnimationFrame(copy);
    }

    function capturePreviews() {
        const handler = e => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = view.videoWidth;
            canvas.height = view.videoHeight;
            ctx.drawImage(view, 0, 0);

            const li = document.createElement('li');
            li.appendChild(canvas);
            streamPreview.appendChild(li);

            if(previewTimes.length) {
                view.currentTime = previewTimes.shift();
            } else {
                view.removeEventListener('timeupdate', handler);
                view.currentTime = 0;
            }
        };
        view.addEventListener('timeupdate', handler);
        view.currentTime = previewTimes.shift();
    }

    view.addEventListener('timeupdate', e => {
        curTimeText.textContent = convertTimeText(view.currentTime);
    });

    view.addEventListener('play', e => {
        playPreview();
        playPauseBtn.classList.add('playing');
    });

    view.addEventListener('pause', e => {
        playPauseBtn.classList.remove('playing');
    });

    view.addEventListener('seeking', e => {
        moveHandlePosition();
    });

    view.addEventListener('ended', e => {
        playPauseBtn.classList.remove('playing');
        moveHandlePosition();
    });

    view.addEventListener('error', e => {
        console.log('error', e);
    });

    view.addEventListener('click', e => {
        togglePlay();
    });

    playPauseBtn.addEventListener('click', e => {
        if (view.readyState !== 4) {
            console.log('not ready');
            return;
        }
        togglePlay();
    });

    function togglePlay() {
        if (view.paused || view.ended) {
            view.play();
        } else {
            view.pause();
        }
    }

    let handleMoving = false;
    let originalHandleX = undefined;

    seekingCtrl.addEventListener('mousedown', e => {
        const target = e.target || e.srcElement;
        if (target === seekingHandle) {
            handleMoving = true;
            originalHandleX = getRelativeHandlePos(e.clientX)
        } else if (target === seekingCtrl) {
            view.currentTime = previewScale(e.clientX - seekingCtrlBBox.x);
        }
    });

    seekingCtrl.addEventListener('mousemove', e => {
        if (!handleMoving) return;

        const mx = originalHandleX - getRelativeHandlePos(e.clientX);
        view.currentTime = previewScale(originalHandleX - mx);
    });

    function getRelativeHandlePos(clientX) {
        return clientX - seekingCtrlBBox.x
    }

    seekingCtrl.addEventListener('mouseup', e => {
        if (!handleMoving) return;

        stopHandleMoving();
    });

    seekingCtrl.addEventListener('mouseleave', e => {
        if (!handleMoving) return;

        stopHandleMoving();
    });

    function playPreview() {
        if (view.paused || view.ended) {
            return;
        }
        moveHandlePosition();
        window.requestAnimationFrame(playPreview);
    }

    function moveHandlePosition() {
        const position = previewScale.invert(view.currentTime);
        curTimeMarker.style.left = `${position}px`;
    }

    function stopHandleMoving() {
        handleMoving = false;
        originalHandleX = undefined;
    }

    function convertTimeText(totalSeconds) {
        const seconds = totalSeconds / (60 ** 0) % 60|0;
        const minutes = totalSeconds / (60 ** 1) % 60|0;
        const hours = totalSeconds / (60 ** 2)|0;
        const minSecText = `${minutes < 10 ? '0' + minutes : minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
        return hours < 1 ? minSecText : `${hours}:${minSecText}`;
    }
</script>
</body>
</html>